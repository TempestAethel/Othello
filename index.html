<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(to top left, #1E8278, #309390, #5F4764),
                        linear-gradient(to bottom right, #000000, #222222, #1E8278);
            opacity: 0.8;
            color: white;
            font-family: Arial, sans-serif;
            position: relative;
            animation: backgroundAnimation 15s ease-in-out infinite, backgroundMovement 30s linear infinite;
            background-size: 200% 200%;
        }

        @keyframes backgroundAnimation {
            0% { background: linear-gradient(to top left, #1E8278, #309390, #5F4764), linear-gradient(to bottom right, #000000, #222222, #1E8278); }
            25% { background: linear-gradient(to top left, #3F9B8B, #4DAE97, #7F7C92), linear-gradient(to bottom right, #111111, #333333, #3F9B8B); }
            50% { background: linear-gradient(to top left, #5FBAA7, #6CC3B3, #B89FA7), linear-gradient(to bottom right, #222222, #444444, #5FBAA7); }
            75% { background: linear-gradient(to top left, #4E7F81, #5A9B98, #A76B76), linear-gradient(to bottom right, #111111, #222222, #4E7F81); }
            100% { background: linear-gradient(to top left, #1E8278, #309390, #5F4764), linear-gradient(to bottom right, #000000, #222222, #1E8278); }
        }

        @keyframes backgroundMovement {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        h1 { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); margin: 0; font-size: 4em; text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.8); letter-spacing: 3px; }
        #controls { margin-bottom: 20px; text-align: center; display: flex; flex-direction: column; gap: 20px; padding: 20px; background: rgba(0, 0, 0, 0.8); border-radius: 10px; box-shadow: 0 0 30px rgba(0, 0, 0, 0.5); width: 300px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        label { font-weight: bold; font-size: 1.2em; }
        select, button { padding: 12px; border: none; border-radius: 5px; font-size: 18px; cursor: pointer; transition: background 0.3s, transform 0.2s; width: 100%; }
        select:hover, button:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
        #board { display: grid; border: 2px solid #ffffff; margin: 20px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); visibility: hidden; transition: visibility 0s, opacity 0.5s linear; opacity: 0; }
        #board.visible { visibility: visible; opacity: 1; }
        .cell { width: 50px; height: 50px; border: 1px solid #ffffff; position: relative; cursor: pointer; transition: background 0.3s; }
        .cell:hover { background: rgba(255, 255, 255, 0.1); }
        .piece { position: absolute; width: 80%; height: 80%; border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .black { background: black; }
        .white { background: white; }
        #status { margin-top: 20px; visibility: hidden; }
        #reset { display: none; margin: 10px auto; padding: 10px; border-radius: 5px; border: none; background: rgba(255, 255, 255, 0.2); color: white; font-size: 16px; transition: background 0.3s, transform 0.2s, opacity 0.3s; opacity: 0.8; width: 150px; }
        #reset:hover { background: rgba(255, 255, 255, 0.3); opacity: 1; }
        #infoButton { position: absolute; top: 20px; right: 20px; padding: 10px; border-radius: 5px; background: rgba(255, 255, 255, 0.2); color: white; font-size: 16px; cursor: pointer; transition: background 0.3s, transform 0.2s; width: auto; }
        #infoButton:hover { background: rgba(255, 255, 255, 0.3); }
        #rules { display: none; position: absolute; top: 60px; right: 20px; background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 5px; color: white; width: 200px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); }
    </style>
</head>
<body>
    <h1>Othello</h1>
    <div id="controls">
        <label for="mode">Game Mode:</label>
        <select id="mode">
            <option value="2player">Two Players</option>
            <option value="easyAI">Easy AI</option>
            <option value="hardAI">Hard AI</option>
        </select>
        <label for="size">Board Size:</label>
        <select id="size">
            <option value="4">4x4</option>
            <option value="5">5x5</option>
            <option value="6">6x6</option>
            <option value="7">7x7</option>
            <option value="8" selected>8x8</option>
            <option value="9">9x9</option>
            <option value="10">10x10</option>
            <option value="11">11x11</option>
            <option value="12">12x12</option>
        </select>
        <button id="start">Start Game</button>
    </div>
    <div id="board" class="visible"></div>
    <button id="reset">Reset Game</button>
    <div id="status"></div>
    <button id="infoButton">Info</button>
    <div id="rules">
        <h3>Othello Rules</h3>
        <p>1. Players take turns placing pieces on the board.</p>
        <p>2. A piece must outflank one or more of the opponent's pieces.</p>
        <p>3. All outflanked pieces are flipped to the current player's color.</p>
        <p>4. The game ends when neither player can make a move.</p>
        <p>5. The player with the most pieces on the board wins.</p>
    </div>

    <script>
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const modeSelect = document.getElementById('mode');
        const sizeSelect = document.getElementById('size');
        const startButton = document.getElementById('start');
        const resetButton = document.getElementById('reset');
        const infoButton = document.getElementById('infoButton');
        const rulesElement = document.getElementById('rules');

        let board = [];
        let currentPlayer = 'black';
        let boardSize = 8;
        let gameMode = '2player';

        function createBoard(size) {
            board = Array.from({ length: size }, () => Array(size).fill(null));
            
            // Set initial pieces for standard Othello start
            board[Math.floor(size / 2) - 1][Math.floor(size / 2) - 1] = 'white';
            board[Math.floor(size / 2)][Math.floor(size / 2)] = 'white';
            board[Math.floor(size / 2) - 1][Math.floor(size / 2)] = 'black';
            board[Math.floor(size / 2)][Math.floor(size / 2) - 1] = 'black';

            renderBoard();
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            board.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const cellElement = document.createElement('div');
                    cellElement.className = 'cell';
                    cellElement.addEventListener('click', () => handleCellClick(rowIndex, colIndex));
                    if (cell) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${cell}`;
                        cellElement.appendChild(pieceElement);
                    }
                    boardElement.appendChild(cellElement);
                });
            });
            boardElement.classList.add('visible');
            statusElement.innerText = `${currentPlayer}'s Turn`;
            statusElement.style.visibility = 'visible';
        }

        function handleCellClick(row, col) {
            if (!board[row][col] && isValidMove(row, col, currentPlayer)) {
                board[row][col] = currentPlayer;
                flipPieces(row, col);
                currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                renderBoard();
                checkGameOver();
                
                if (gameMode !== '2player' && currentPlayer === 'white') {
                    setTimeout(aiMove, 500);
                }
            }
        }

        function isValidMove(row, col, color) {
            const directions = [
                { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 1, y: 0 },
                { x: 1, y: -1 }, { x: 0, y: -1 }, { x: -1, y: -1 },
                { x: -1, y: 0 }, { x: -1, y: 1 }
            ];

            for (const { x, y } of directions) {
                let i = row + x, j = col + y, hasOpponentPiece = false;

                while (i >= 0 && j >= 0 && i < board.length && j < board.length) {
                    if (board[i][j] === null) break;
                    if (board[i][j] === color) {
                        if (hasOpponentPiece) return true;
                        break;
                    }
                    hasOpponentPiece = true;
                    i += x;
                    j += y;
                }
            }
            return false;
        }

        function flipPieces(row, col) {
            const directions = [
                { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 1, y: 0 },
                { x: 1, y: -1 }, { x: 0, y: -1 }, { x: -1, y: -1 },
                { x: -1, y: 0 }, { x: -1, y: 1 }
            ];

            for (const { x, y } of directions) {
                let i = row + x, j = col + y, piecesToFlip = [];

                while (i >= 0 && j >= 0 && i < board.length && j < board.length) {
                    if (board[i][j] === null) break;
                    if (board[i][j] === currentPlayer) {
                        for (const [flipRow, flipCol] of piecesToFlip) {
                            board[flipRow][flipCol] = currentPlayer;
                        }
                        break;
                    }
                    piecesToFlip.push([i, j]);
                    i += x;
                    j += y;
                }
            }
        }

        function checkGameOver() {
            const movesAvailable = board.flat().some((cell, index) => {
                const row = Math.floor(index / board.length);
                const col = index % board.length;
                return cell === null && isValidMove(row, col, currentPlayer);
            });

            if (!movesAvailable) {
                currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                const opponentMovesAvailable = board.flat().some((cell, index) => {
                    const row = Math.floor(index / board.length);
                    const col = index % board.length;
                    return cell === null && isValidMove(row, col, currentPlayer);
                });

                if (!opponentMovesAvailable) {
                    declareWinner();
                } else {
                    statusElement.innerText = `${currentPlayer}'s Turn`;
                }
            }
        }

        function declareWinner() {
            const blackCount = board.flat().filter(cell => cell === 'black').length;
            const whiteCount = board.flat().filter(cell => cell === 'white').length;

            if (blackCount > whiteCount) {
                statusElement.innerText = 'Black wins!';
            } else if (whiteCount > blackCount) {
                statusElement.innerText = 'White wins!';
            } else {
                statusElement.innerText = 'It\'s a tie!';
            }
            resetButton.style.display = 'block';
        }

        function aiMove() {
            let bestMove;
            if (gameMode === 'easyAI') {
                bestMove = getRandomMove();
            } else if (gameMode === 'hardAI') {
                bestMove = minimaxMove();
            }
            if (bestMove) {
                handleCellClick(bestMove.row, bestMove.col);
            }
        }

        function getRandomMove() {
            const validMoves = [];
            board.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cell === null && isValidMove(rowIndex, colIndex, 'white')) {
                        validMoves.push({ row: rowIndex, col: colIndex });
                    }
                });
            });
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        function minimaxMove() {
            let bestValue = -Infinity;
            let bestMove = null;

            board.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cell === null && isValidMove(rowIndex, colIndex, 'white')) {
                        board[rowIndex][colIndex] = 'white';
                        let moveValue = minimax(0, false);
                        board[rowIndex][colIndex] = null; // Undo move

                        if (moveValue > bestValue) {
                            bestValue = moveValue;
                            bestMove = { row: rowIndex, col: colIndex };
                        }
                    }
                });
            });
            return bestMove;
        }

        function minimax(depth, isMaximizing) {
            if (depth > 3) return evaluateBoard();

            if (isMaximizing) {
                let maxEval = -Infinity;
                board.forEach((row, rowIndex) => {
                    row.forEach((cell, colIndex) => {
                        if (cell === null && isValidMove(rowIndex, colIndex, 'white')) {
                            board[rowIndex][colIndex] = 'white';
                            let eval = minimax(depth + 1, false);
                            board[rowIndex][colIndex] = null; // Undo move
                            maxEval = Math.max(maxEval, eval);
                        }
                    });
                });
                return maxEval;
            } else {
                let minEval = Infinity;
                board.forEach((row, rowIndex) => {
                    row.forEach((cell, colIndex) => {
                        if (cell === null && isValidMove(rowIndex, colIndex, 'black')) {
                            board[rowIndex][colIndex] = 'black';
                            let eval = minimax(depth + 1, true);
                            board[rowIndex][colIndex] = null; // Undo move
                            minEval = Math.min(minEval, eval);
                        }
                    });
                });
                return minEval;
            }
        }

        function evaluateBoard() {
            const blackCount = board.flat().filter(cell => cell === 'black').length;
            const whiteCount = board.flat().filter(cell => cell === 'white').length;
            return whiteCount - blackCount; // More white pieces is better
        }

        startButton.addEventListener('click', () => {
            boardSize = parseInt(sizeSelect.value);
            gameMode = modeSelect.value;
            createBoard(boardSize);
            resetButton.style.display = 'none';
        });

        resetButton.addEventListener('click', () => {
            createBoard(boardSize);
            resetButton.style.display = 'none';
        });

        infoButton.addEventListener('click', () => {
            rulesElement.style.display = rulesElement.style.display === 'block' ? 'none' : 'block';
        });
    </script>
</body>
</html>
