<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(to right, #232526, #414345);
            color: white;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        h1 {
            margin-bottom: 20px;
            font-size: 64px;
            text-shadow: 3px 3px 15px rgba(0, 0, 0, 0.7);
            font-family: 'Georgia', serif; /* More appealing font */
        }
        #controls {
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        .info-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 5px;
            color: white;
            padding: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .info-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        label {
            font-weight: bold;
        }
        select, button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        }
        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }
        #board {
            display: grid;
            border: 2px solid #ffffff;
            margin: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            visibility: hidden; /* Start hidden */
            transition: visibility 0s, opacity 0.5s linear;
            opacity: 0;
        }
        #board.visible {
            visibility: visible;
            opacity: 1;
        }
        .cell {
            width: 10vw; /* Responsive width */
            height: 10vw; /* Responsive height */
            min-width: 50px; /* Minimum size */
            min-height: 50px; /* Minimum size */
            border: 1px solid #ffffff;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        .cell:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .piece {
            position: absolute;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .black {
            background: black;
        }
        .white {
            background: white;
        }
        #status {
            margin-top: 20px;
            visibility: hidden;
        }
        #reset {
            display: none;
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            border: none;
            background: #ff4444;
            color: white;
            transition: background 0.3s;
        }
        #reset:hover {
            background: #ff0000;
        }
        #rules {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            z-index: 100;
        }
        #close-rules {
            background: #ff4444;
            border: none;
            border-radius: 5px;
            color: white;
            padding: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #close-rules:hover {
            background: #ff0000;
        }
    </style>
</head>
<body>
    <h1>Othello</h1>
    <button class="info-button" id="infoButton">Info</button>
    <div id="controls">
        <label for="mode">Game Mode:</label>
        <select id="mode">
            <option value="2player">Two Players</option>
            <option value="easyAI">Easy AI</option>
            <option value="hardAI">Hard AI</option>
        </select>
        <label for="size">Board Size:</label>
        <select id="size">
            <option value="4">4x4</option>
            <option value="6">6x6</option>
            <option value="8" selected>8x8</option>
            <option value="10">10x10</option>
            <option value="12">12x12</option>
        </select>
        <button id="start">Start Game</button>
    </div>
    <div id="board"></div>
    <button id="reset">Reset Game</button>
    <div id="status"></div>

    <div id="rules">
        <h2>Game Rules</h2>
        <p>Othello is played on an 8x8 board with two players taking turns placing pieces. The objective is to have the majority of pieces on the board at the end of the game.</p>
        <h3>Rules:</h3>
        <ul>
            <li>Players take turns placing their pieces on the board.</li>
            <li>A piece can be placed if it outflanks one or more of the opponent's pieces in any direction (horizontally, vertically, or diagonally).</li>
            <li>When a player places a piece, all opponent's pieces that are outflanked are flipped to the player's color.</li>
            <li>The game ends when neither player can make a valid move.</li>
            <li>The player with the most pieces on the board wins.</li>
        </ul>
        <button id="close-rules">Close</button>
    </div>

    <script>
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const modeSelect = document.getElementById('mode');
        const sizeSelect = document.getElementById('size');
        const startButton = document.getElementById('start');
        const resetButton = document.getElementById('reset');
        const rulesElement = document.getElementById('rules');
        const infoButton = document.getElementById('infoButton');
        const closeRulesButton = document.getElementById('close-rules');

        let boardSize = 8;
        let board = [];
        let currentPlayer = 'black';
        let gameMode = '2player';
        let scores = { black: 2, white: 2 };
        let gameEnded = false;

        function initializeBoard() {
            board = Array.from({ length: boardSize }, () => Array(boardSize).fill(null));
            const mid = Math.floor(boardSize / 2);
            board[mid - 1][mid - 1] = 'white';
            board[mid][mid] = 'white';
            board[mid - 1][mid] = 'black';
            board[mid][mid - 1] = 'black';
            renderBoard();
            gameEnded = false;
            boardElement.classList.add('visible'); // Show board when initialized
            resetButton.style.display = 'block'; // Show reset button
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            boardElement.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`; // Use fractional units for responsiveness
            boardElement.style.gridTemplateRows = `repeat(${boardSize}, 1fr)`; // Use fractional units for responsiveness

            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    if (board[row][col]) {
                        const piece = document.createElement('div');
                        piece.className = `piece ${board[row][col]}`;
                        cell.appendChild(piece);
                    }

                    cell.addEventListener('click', () => handleCellClick(row, col));
                    boardElement.appendChild(cell);
                }
            }
            updateScores();
        }

        function handleCellClick(row, col) {
            if (!gameEnded && validMove(row, col)) {
                placePiece(row, col);
                if (gameMode.includes('AI')) {
                    setTimeout(() => {
                        if (!gameEnded) {
                            if (gameMode === 'easyAI') {
                                easyAIMove();
                            } else {
                                hardAIMove();
                            }
                        }
                    }, 500);
                }
            }
            if (checkGameOver()) {
                endGame();
            }
        }

        function validMove(row, col) {
            if (board[row][col] !== null) return false;

            const directions = [
                { x: 0, y: -1 }, // Up
                { x: 0, y: 1 },  // Down
                { x: -1, y: 0 }, // Left
                { x: 1, y: 0 },  // Right
                { x: -1, y: -1 }, // Up Left
                { x: -1, y: 1 },  // Up Right
                { x: 1, y: -1 },  // Down Left
                { x: 1, y: 1 }    // Down Right
            ];

            for (let { x, y } of directions) {
                let r = row + y;
                let c = col + x;
                let hasOpponentPiece = false;

                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
                    if (board[r][c] === null) break;
                    if (board[r][c] === currentPlayer) {
                        if (hasOpponentPiece) return true;
                        break;
                    }
                    hasOpponentPiece = true;
                    r += y;
                    c += x;
                }
            }
            return false;
        }

        function placePiece(row, col) {
            board[row][col] = currentPlayer;
            flipPieces(row, col);
            updateScores();
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            updateStatus();
        }

        function flipPieces(row, col) {
            const directions = [
                { x: 0, y: -1 }, // Up
                { x: 0, y: 1 },  // Down
                { x: -1, y: 0 }, // Left
                { x: 1, y: 0 },  // Right
                { x: -1, y: -1 }, // Up Left
                { x: -1, y: 1 },  // Up Right
                { x: 1, y: -1 },  // Down Left
                { x: 1, y: 1 }    // Down Right
            ];

            for (let { x, y } of directions) {
                let r = row + y;
                let c = col + x;
                const piecesToFlip = [];

                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
                    if (board[r][c] === null) break;
                    if (board[r][c] === currentPlayer) {
                        for (let piece of piecesToFlip) {
                            board[piece.r][piece.c] = currentPlayer;
                        }
                        break;
                    }
                    piecesToFlip.push({ r, c });
                    r += y;
                    c += x;
                }
            }
        }

        function updateScores() {
            scores.black = 0;
            scores.white = 0;
            for (let row of board) {
                for (let cell of row) {
                    if (cell === 'black') scores.black++;
                    if (cell === 'white') scores.white++;
                }
            }
            updateStatus();
        }

        function updateStatus() {
            statusElement.textContent = `Black: ${scores.black}, White: ${scores.white}`;
            statusElement.style.visibility = 'visible';
        }

        function easyAIMove() {
            const validMoves = getValidMoves();
            if (validMoves.length) {
                const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                placePiece(move.row, move.col);
            }
        }

        function hardAIMove() {
            const validMoves = getValidMoves();
            if (validMoves.length) {
                let bestMove = validMoves[0];
                let bestScore = -1;
                for (let move of validMoves) {
                    const tempBoard = board.map(row => row.slice());
                    tempBoard[move.row][move.col] = 'white';
                    const score = evaluateBoard(tempBoard);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                placePiece(bestMove.row, bestMove.col);
            }
        }

        function getValidMoves() {
            const moves = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (validMove(row, col)) {
                        moves.push({ row, col });
                    }
                }
            }
            return moves;
        }

        function evaluateBoard(tempBoard) {
            let score = 0;
            for (let row of tempBoard) {
                for (let cell of row) {
                    if (cell === 'white') score++;
                    else if (cell === 'black') score--;
                }
            }
            return score;
        }

        function checkGameOver() {
            const validMoves = getValidMoves();
            if (validMoves.length === 0) {
                currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                return getValidMoves().length === 0;
            }
            return false;
        }

        function endGame() {
            gameEnded = true;
            const winner = scores.black > scores.white ? 'Black wins!' : (scores.white > scores.black ? 'White wins!' : 'It\'s a tie!');
            statusElement.textContent = winner;
            resetButton.style.display = 'block';
            boardElement.classList.remove('visible'); // Hide board at end
        }

        function startGame() {
            boardSize = parseInt(sizeSelect.value);
            gameMode = modeSelect.value;
            initializeBoard();
            document.getElementById('controls').style.display = 'none';
        }

        function resetGame() {
            document.getElementById('controls').style.display = 'flex';
            resetButton.style.display = 'none';
            statusElement.style.visibility = 'hidden';
            boardElement.classList.remove('visible'); // Hide board on reset
            boardElement.innerHTML = ''; // Clear the board
            scores = { black: 2, white: 2 }; // Reset scores
        }

        infoButton.addEventListener('click', () => {
            rulesElement.style.display = 'block';
        });

        closeRulesButton.addEventListener('click', () => {
            rulesElement.style.display = 'none';
        });

        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // Initialize the game
        initializeBoard();
    </script>
</body>
</html>
